// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PLA_CANOPY_IO_H_
#define FLATBUFFERS_GENERATED_PLA_CANOPY_IO_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace canopy {
namespace io {

struct PLA;
struct PLABuilder;

enum PLAType : int8_t {
  PLAType_DNF = 0,
  PLAType_CNF = 1,
  PLAType_MIN = PLAType_DNF,
  PLAType_MAX = PLAType_CNF
};

inline const PLAType (&EnumValuesPLAType())[2] {
  static const PLAType values[] = {
    PLAType_DNF,
    PLAType_CNF
  };
  return values;
}

inline const char * const *EnumNamesPLAType() {
  static const char * const names[3] = {
    "DNF",
    "CNF",
    nullptr
  };
  return names;
}

inline const char *EnumNamePLAType(PLAType e) {
  if (::flatbuffers::IsOutRange(e, PLAType_DNF, PLAType_CNF)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPLAType()[index];
}

struct PLA FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PLABuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_PRODUCTS = 6,
    VT_NUM_PRODUCTS = 8,
    VT_NUM_EVENTS_PER_PRODUCT = 10
  };
  canopy::io::PLAType type() const {
    return static_cast<canopy::io::PLAType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::Vector<uint8_t> *products() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PRODUCTS);
  }
  uint64_t num_products() const {
    return GetField<uint64_t>(VT_NUM_PRODUCTS, 0);
  }
  uint64_t num_events_per_product() const {
    return GetField<uint64_t>(VT_NUM_EVENTS_PER_PRODUCT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffset(verifier, VT_PRODUCTS) &&
           verifier.VerifyVector(products()) &&
           VerifyField<uint64_t>(verifier, VT_NUM_PRODUCTS, 8) &&
           VerifyField<uint64_t>(verifier, VT_NUM_EVENTS_PER_PRODUCT, 8) &&
           verifier.EndTable();
  }
};

struct PLABuilder {
  typedef PLA Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(canopy::io::PLAType type) {
    fbb_.AddElement<int8_t>(PLA::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_products(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> products) {
    fbb_.AddOffset(PLA::VT_PRODUCTS, products);
  }
  void add_num_products(uint64_t num_products) {
    fbb_.AddElement<uint64_t>(PLA::VT_NUM_PRODUCTS, num_products, 0);
  }
  void add_num_events_per_product(uint64_t num_events_per_product) {
    fbb_.AddElement<uint64_t>(PLA::VT_NUM_EVENTS_PER_PRODUCT, num_events_per_product, 0);
  }
  explicit PLABuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PLA> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PLA>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PLA> CreatePLA(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    canopy::io::PLAType type = canopy::io::PLAType_DNF,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> products = 0,
    uint64_t num_products = 0,
    uint64_t num_events_per_product = 0) {
  PLABuilder builder_(_fbb);
  builder_.add_num_events_per_product(num_events_per_product);
  builder_.add_num_products(num_products);
  builder_.add_products(products);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<PLA> CreatePLADirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    canopy::io::PLAType type = canopy::io::PLAType_DNF,
    const std::vector<uint8_t> *products = nullptr,
    uint64_t num_products = 0,
    uint64_t num_events_per_product = 0) {
  auto products__ = products ? _fbb.CreateVector<uint8_t>(*products) : 0;
  return canopy::io::CreatePLA(
      _fbb,
      type,
      products__,
      num_products,
      num_events_per_product);
}

inline const canopy::io::PLA *GetPLA(const void *buf) {
  return ::flatbuffers::GetRoot<canopy::io::PLA>(buf);
}

inline const canopy::io::PLA *GetSizePrefixedPLA(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<canopy::io::PLA>(buf);
}

inline const char *PLAIdentifier() {
  return "BPLA";
}

inline bool PLABufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PLAIdentifier());
}

inline bool SizePrefixedPLABufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, PLAIdentifier(), true);
}

inline bool VerifyPLABuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<canopy::io::PLA>(PLAIdentifier());
}

inline bool VerifySizePrefixedPLABuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<canopy::io::PLA>(PLAIdentifier());
}

inline const char *PLAExtension() {
  return "bits";
}

inline void FinishPLABuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<canopy::io::PLA> root) {
  fbb.Finish(root, PLAIdentifier());
}

inline void FinishSizePrefixedPLABuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<canopy::io::PLA> root) {
  fbb.FinishSizePrefixed(root, PLAIdentifier());
}

}  // namespace io
}  // namespace canopy

#endif  // FLATBUFFERS_GENERATED_PLA_CANOPY_IO_H_

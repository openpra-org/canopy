// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMAV1_CANOPY_IO_H_
#define FLATBUFFERS_GENERATED_SCHEMAV1_CANOPY_IO_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace canopy {
namespace io {

struct Tensor;
struct TensorBuilder;

struct KofNArgs;
struct KofNArgsBuilder;

struct MonteCarloExpectedValueOptions;
struct MonteCarloExpectedValueOptionsBuilder;

struct ReshapeArgs;
struct ReshapeArgsBuilder;

struct Operator;
struct OperatorBuilder;

struct SubGraph;
struct SubGraphBuilder;

struct Buffer;
struct BufferBuilder;

struct DAGs;
struct DAGsBuilder;

enum TensorType : uint8_t {
  TensorType_UINT32 = 0,
  TensorType_UINT4 = 4,
  TensorType_UINT8 = 8,
  TensorType_UINT16 = 16,
  TensorType_UINT64 = 64,
  TensorType_FLOAT16 = 144,
  TensorType_FLOAT32 = 160,
  TensorType_FLOAT64 = 192,
  TensorType_MIN = TensorType_UINT32,
  TensorType_MAX = TensorType_FLOAT64
};

inline const TensorType (&EnumValuesTensorType())[8] {
  static const TensorType values[] = {
    TensorType_UINT32,
    TensorType_UINT4,
    TensorType_UINT8,
    TensorType_UINT16,
    TensorType_UINT64,
    TensorType_FLOAT16,
    TensorType_FLOAT32,
    TensorType_FLOAT64
  };
  return values;
}

inline const char *EnumNameTensorType(TensorType e) {
  switch (e) {
    case TensorType_UINT32: return "UINT32";
    case TensorType_UINT4: return "UINT4";
    case TensorType_UINT8: return "UINT8";
    case TensorType_UINT16: return "UINT16";
    case TensorType_UINT64: return "UINT64";
    case TensorType_FLOAT16: return "FLOAT16";
    case TensorType_FLOAT32: return "FLOAT32";
    case TensorType_FLOAT64: return "FLOAT64";
    default: return "";
  }
}

enum OpCode : uint8_t {
  OpCode_BITWISE_NOT = 0,
  OpCode_BITWISE_AND = 1,
  OpCode_BITWISE_OR = 2,
  OpCode_BITWISE_XOR = 4,
  OpCode_BITWISE_K_OF_N = 5,
  OpCode_BITWISE_NAND = 9,
  OpCode_BITWISE_NOR = 10,
  OpCode_BITWISE_XNOR = 12,
  OpCode_BITMASK_ZEROS = 16,
  OpCode_BITMASK_ONES = 17,
  OpCode_BITWISE_CONV_ND = 32,
  OpCode_BITWISE_CONV_1D = 33,
  OpCode_BITWISE_CONV_2D = 34,
  OpCode_BITWISE_FFT_ND = 64,
  OpCode_BITWISE_FFT_1D = 65,
  OpCode_BITWISE_FFT_2D = 66,
  OpCode_LOGICAL_NOT = 128,
  OpCode_LOGICAL_AND = 129,
  OpCode_LOGICAL_OR = 130,
  OpCode_LOGICAL_XOR = 132,
  OpCode_LOGICAL_NAND = 137,
  OpCode_LOGICAL_NOR = 138,
  OpCode_LOGICAL_XNOR = 140,
  OpCode_RESHAPE = 160,
  OpCode_MC_EXPECT_VAL = 240,
  OpCode_MC_VAR_LOSS = 241,
  OpCode_MIN = OpCode_BITWISE_NOT,
  OpCode_MAX = OpCode_MC_VAR_LOSS
};

inline const OpCode (&EnumValuesOpCode())[26] {
  static const OpCode values[] = {
    OpCode_BITWISE_NOT,
    OpCode_BITWISE_AND,
    OpCode_BITWISE_OR,
    OpCode_BITWISE_XOR,
    OpCode_BITWISE_K_OF_N,
    OpCode_BITWISE_NAND,
    OpCode_BITWISE_NOR,
    OpCode_BITWISE_XNOR,
    OpCode_BITMASK_ZEROS,
    OpCode_BITMASK_ONES,
    OpCode_BITWISE_CONV_ND,
    OpCode_BITWISE_CONV_1D,
    OpCode_BITWISE_CONV_2D,
    OpCode_BITWISE_FFT_ND,
    OpCode_BITWISE_FFT_1D,
    OpCode_BITWISE_FFT_2D,
    OpCode_LOGICAL_NOT,
    OpCode_LOGICAL_AND,
    OpCode_LOGICAL_OR,
    OpCode_LOGICAL_XOR,
    OpCode_LOGICAL_NAND,
    OpCode_LOGICAL_NOR,
    OpCode_LOGICAL_XNOR,
    OpCode_RESHAPE,
    OpCode_MC_EXPECT_VAL,
    OpCode_MC_VAR_LOSS
  };
  return values;
}

inline const char *EnumNameOpCode(OpCode e) {
  switch (e) {
    case OpCode_BITWISE_NOT: return "BITWISE_NOT";
    case OpCode_BITWISE_AND: return "BITWISE_AND";
    case OpCode_BITWISE_OR: return "BITWISE_OR";
    case OpCode_BITWISE_XOR: return "BITWISE_XOR";
    case OpCode_BITWISE_K_OF_N: return "BITWISE_K_OF_N";
    case OpCode_BITWISE_NAND: return "BITWISE_NAND";
    case OpCode_BITWISE_NOR: return "BITWISE_NOR";
    case OpCode_BITWISE_XNOR: return "BITWISE_XNOR";
    case OpCode_BITMASK_ZEROS: return "BITMASK_ZEROS";
    case OpCode_BITMASK_ONES: return "BITMASK_ONES";
    case OpCode_BITWISE_CONV_ND: return "BITWISE_CONV_ND";
    case OpCode_BITWISE_CONV_1D: return "BITWISE_CONV_1D";
    case OpCode_BITWISE_CONV_2D: return "BITWISE_CONV_2D";
    case OpCode_BITWISE_FFT_ND: return "BITWISE_FFT_ND";
    case OpCode_BITWISE_FFT_1D: return "BITWISE_FFT_1D";
    case OpCode_BITWISE_FFT_2D: return "BITWISE_FFT_2D";
    case OpCode_LOGICAL_NOT: return "LOGICAL_NOT";
    case OpCode_LOGICAL_AND: return "LOGICAL_AND";
    case OpCode_LOGICAL_OR: return "LOGICAL_OR";
    case OpCode_LOGICAL_XOR: return "LOGICAL_XOR";
    case OpCode_LOGICAL_NAND: return "LOGICAL_NAND";
    case OpCode_LOGICAL_NOR: return "LOGICAL_NOR";
    case OpCode_LOGICAL_XNOR: return "LOGICAL_XNOR";
    case OpCode_RESHAPE: return "RESHAPE";
    case OpCode_MC_EXPECT_VAL: return "MC_EXPECT_VAL";
    case OpCode_MC_VAR_LOSS: return "MC_VAR_LOSS";
    default: return "";
  }
}

enum OperatorArgs : uint8_t {
  OperatorArgs_NONE = 0,
  OperatorArgs_KofNArgs = 1,
  OperatorArgs_ReshapeArgs = 2,
  OperatorArgs_MonteCarloExpectedValueOptions = 3,
  OperatorArgs_MIN = OperatorArgs_NONE,
  OperatorArgs_MAX = OperatorArgs_MonteCarloExpectedValueOptions
};

inline const OperatorArgs (&EnumValuesOperatorArgs())[4] {
  static const OperatorArgs values[] = {
    OperatorArgs_NONE,
    OperatorArgs_KofNArgs,
    OperatorArgs_ReshapeArgs,
    OperatorArgs_MonteCarloExpectedValueOptions
  };
  return values;
}

inline const char * const *EnumNamesOperatorArgs() {
  static const char * const names[5] = {
    "NONE",
    "KofNArgs",
    "ReshapeArgs",
    "MonteCarloExpectedValueOptions",
    nullptr
  };
  return names;
}

inline const char *EnumNameOperatorArgs(OperatorArgs e) {
  if (::flatbuffers::IsOutRange(e, OperatorArgs_NONE, OperatorArgs_MonteCarloExpectedValueOptions)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOperatorArgs()[index];
}

template<typename T> struct OperatorArgsTraits {
  static const OperatorArgs enum_value = OperatorArgs_NONE;
};

template<> struct OperatorArgsTraits<canopy::io::KofNArgs> {
  static const OperatorArgs enum_value = OperatorArgs_KofNArgs;
};

template<> struct OperatorArgsTraits<canopy::io::ReshapeArgs> {
  static const OperatorArgs enum_value = OperatorArgs_ReshapeArgs;
};

template<> struct OperatorArgsTraits<canopy::io::MonteCarloExpectedValueOptions> {
  static const OperatorArgs enum_value = OperatorArgs_MonteCarloExpectedValueOptions;
};

bool VerifyOperatorArgs(::flatbuffers::Verifier &verifier, const void *obj, OperatorArgs type);
bool VerifyOperatorArgsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct Tensor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE = 4,
    VT_TYPE = 6,
    VT_BUFFER_IDX = 8,
    VT_NAME = 10
  };
  const ::flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  canopy::io::TensorType type() const {
    return static_cast<canopy::io::TensorType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  uint32_t buffer_idx() const {
    return GetField<uint32_t>(VT_BUFFER_IDX, 0);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_BUFFER_IDX, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct TensorBuilder {
  typedef Tensor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(Tensor::VT_SHAPE, shape);
  }
  void add_type(canopy::io::TensorType type) {
    fbb_.AddElement<uint8_t>(Tensor::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_buffer_idx(uint32_t buffer_idx) {
    fbb_.AddElement<uint32_t>(Tensor::VT_BUFFER_IDX, buffer_idx, 0);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Tensor::VT_NAME, name);
  }
  explicit TensorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Tensor> CreateTensor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> shape = 0,
    canopy::io::TensorType type = canopy::io::TensorType_UINT32,
    uint32_t buffer_idx = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_buffer_idx(buffer_idx);
  builder_.add_shape(shape);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Tensor> CreateTensorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *shape = nullptr,
    canopy::io::TensorType type = canopy::io::TensorType_UINT32,
    uint32_t buffer_idx = 0,
    const char *name = nullptr) {
  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return canopy::io::CreateTensor(
      _fbb,
      shape__,
      type,
      buffer_idx,
      name__);
}

struct KofNArgs FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KofNArgsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ATLEAST = 4
  };
  uint32_t atleast() const {
    return GetField<uint32_t>(VT_ATLEAST, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ATLEAST, 4) &&
           verifier.EndTable();
  }
};

struct KofNArgsBuilder {
  typedef KofNArgs Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_atleast(uint32_t atleast) {
    fbb_.AddElement<uint32_t>(KofNArgs::VT_ATLEAST, atleast, 0);
  }
  explicit KofNArgsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KofNArgs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KofNArgs>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KofNArgs> CreateKofNArgs(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t atleast = 0) {
  KofNArgsBuilder builder_(_fbb);
  builder_.add_atleast(atleast);
  return builder_.Finish();
}

struct MonteCarloExpectedValueOptions FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MonteCarloExpectedValueOptionsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CI_LOW = 4,
    VT_CI_HIGH = 6
  };
  float ci_low() const {
    return GetField<float>(VT_CI_LOW, 0.05f);
  }
  float ci_high() const {
    return GetField<float>(VT_CI_HIGH, 0.95f);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_CI_LOW, 4) &&
           VerifyField<float>(verifier, VT_CI_HIGH, 4) &&
           verifier.EndTable();
  }
};

struct MonteCarloExpectedValueOptionsBuilder {
  typedef MonteCarloExpectedValueOptions Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ci_low(float ci_low) {
    fbb_.AddElement<float>(MonteCarloExpectedValueOptions::VT_CI_LOW, ci_low, 0.05f);
  }
  void add_ci_high(float ci_high) {
    fbb_.AddElement<float>(MonteCarloExpectedValueOptions::VT_CI_HIGH, ci_high, 0.95f);
  }
  explicit MonteCarloExpectedValueOptionsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MonteCarloExpectedValueOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MonteCarloExpectedValueOptions>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<MonteCarloExpectedValueOptions> CreateMonteCarloExpectedValueOptions(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float ci_low = 0.05f,
    float ci_high = 0.95f) {
  MonteCarloExpectedValueOptionsBuilder builder_(_fbb);
  builder_.add_ci_high(ci_high);
  builder_.add_ci_low(ci_low);
  return builder_.Finish();
}

struct ReshapeArgs FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReshapeArgsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEW_SHAPE = 4
  };
  const ::flatbuffers::Vector<int32_t> *new_shape() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_NEW_SHAPE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NEW_SHAPE) &&
           verifier.VerifyVector(new_shape()) &&
           verifier.EndTable();
  }
};

struct ReshapeArgsBuilder {
  typedef ReshapeArgs Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_new_shape(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> new_shape) {
    fbb_.AddOffset(ReshapeArgs::VT_NEW_SHAPE, new_shape);
  }
  explicit ReshapeArgsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReshapeArgs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReshapeArgs>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReshapeArgs> CreateReshapeArgs(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> new_shape = 0) {
  ReshapeArgsBuilder builder_(_fbb);
  builder_.add_new_shape(new_shape);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ReshapeArgs> CreateReshapeArgsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *new_shape = nullptr) {
  auto new_shape__ = new_shape ? _fbb.CreateVector<int32_t>(*new_shape) : 0;
  return canopy::io::CreateReshapeArgs(
      _fbb,
      new_shape__);
}

struct Operator FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OperatorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OPCODE = 4,
    VT_ARGS_TYPE = 6,
    VT_ARGS = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS = 12,
    VT_NAME = 14
  };
  canopy::io::OpCode opcode() const {
    return static_cast<canopy::io::OpCode>(GetField<uint8_t>(VT_OPCODE, 0));
  }
  canopy::io::OperatorArgs args_type() const {
    return static_cast<canopy::io::OperatorArgs>(GetField<uint8_t>(VT_ARGS_TYPE, 0));
  }
  const void *args() const {
    return GetPointer<const void *>(VT_ARGS);
  }
  template<typename T> const T *args_as() const;
  const canopy::io::KofNArgs *args_as_KofNArgs() const {
    return args_type() == canopy::io::OperatorArgs_KofNArgs ? static_cast<const canopy::io::KofNArgs *>(args()) : nullptr;
  }
  const canopy::io::ReshapeArgs *args_as_ReshapeArgs() const {
    return args_type() == canopy::io::OperatorArgs_ReshapeArgs ? static_cast<const canopy::io::ReshapeArgs *>(args()) : nullptr;
  }
  const canopy::io::MonteCarloExpectedValueOptions *args_as_MonteCarloExpectedValueOptions() const {
    return args_type() == canopy::io::OperatorArgs_MonteCarloExpectedValueOptions ? static_cast<const canopy::io::MonteCarloExpectedValueOptions *>(args()) : nullptr;
  }
  const ::flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OPCODE, 1) &&
           VerifyField<uint8_t>(verifier, VT_ARGS_TYPE, 1) &&
           VerifyOffset(verifier, VT_ARGS) &&
           VerifyOperatorArgs(verifier, args(), args_type()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

template<> inline const canopy::io::KofNArgs *Operator::args_as<canopy::io::KofNArgs>() const {
  return args_as_KofNArgs();
}

template<> inline const canopy::io::ReshapeArgs *Operator::args_as<canopy::io::ReshapeArgs>() const {
  return args_as_ReshapeArgs();
}

template<> inline const canopy::io::MonteCarloExpectedValueOptions *Operator::args_as<canopy::io::MonteCarloExpectedValueOptions>() const {
  return args_as_MonteCarloExpectedValueOptions();
}

struct OperatorBuilder {
  typedef Operator Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_opcode(canopy::io::OpCode opcode) {
    fbb_.AddElement<uint8_t>(Operator::VT_OPCODE, static_cast<uint8_t>(opcode), 0);
  }
  void add_args_type(canopy::io::OperatorArgs args_type) {
    fbb_.AddElement<uint8_t>(Operator::VT_ARGS_TYPE, static_cast<uint8_t>(args_type), 0);
  }
  void add_args(::flatbuffers::Offset<void> args) {
    fbb_.AddOffset(Operator::VT_ARGS, args);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(Operator::VT_INPUTS, inputs);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(Operator::VT_OUTPUTS, outputs);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Operator::VT_NAME, name);
  }
  explicit OperatorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Operator> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Operator>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Operator> CreateOperator(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    canopy::io::OpCode opcode = canopy::io::OpCode_BITWISE_NOT,
    canopy::io::OperatorArgs args_type = canopy::io::OperatorArgs_NONE,
    ::flatbuffers::Offset<void> args = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  OperatorBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_args(args);
  builder_.add_args_type(args_type);
  builder_.add_opcode(opcode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Operator> CreateOperatorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    canopy::io::OpCode opcode = canopy::io::OpCode_BITWISE_NOT,
    canopy::io::OperatorArgs args_type = canopy::io::OperatorArgs_NONE,
    ::flatbuffers::Offset<void> args = 0,
    const std::vector<int32_t> *inputs = nullptr,
    const std::vector<int32_t> *outputs = nullptr,
    const char *name = nullptr) {
  auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return canopy::io::CreateOperator(
      _fbb,
      opcode,
      args_type,
      args,
      inputs__,
      outputs__,
      name__);
}

struct SubGraph FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SubGraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TENSORS = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_OPERATORS = 10,
    VT_NAME = 12
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<canopy::io::Tensor>> *tensors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<canopy::io::Tensor>> *>(VT_TENSORS);
  }
  const ::flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<canopy::io::Operator>> *operators() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<canopy::io::Operator>> *>(VT_OPERATORS);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TENSORS) &&
           verifier.VerifyVector(tensors()) &&
           verifier.VerifyVectorOfTables(tensors()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, VT_OPERATORS) &&
           verifier.VerifyVector(operators()) &&
           verifier.VerifyVectorOfTables(operators()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct SubGraphBuilder {
  typedef SubGraph Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_tensors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<canopy::io::Tensor>>> tensors) {
    fbb_.AddOffset(SubGraph::VT_TENSORS, tensors);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(SubGraph::VT_INPUTS, inputs);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(SubGraph::VT_OUTPUTS, outputs);
  }
  void add_operators(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<canopy::io::Operator>>> operators) {
    fbb_.AddOffset(SubGraph::VT_OPERATORS, operators);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(SubGraph::VT_NAME, name);
  }
  explicit SubGraphBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SubGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SubGraph>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SubGraph> CreateSubGraph(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<canopy::io::Tensor>>> tensors = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> outputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<canopy::io::Operator>>> operators = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  SubGraphBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_operators(operators);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_tensors(tensors);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SubGraph> CreateSubGraphDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<canopy::io::Tensor>> *tensors = nullptr,
    const std::vector<int32_t> *inputs = nullptr,
    const std::vector<int32_t> *outputs = nullptr,
    const std::vector<::flatbuffers::Offset<canopy::io::Operator>> *operators = nullptr,
    const char *name = nullptr) {
  auto tensors__ = tensors ? _fbb.CreateVector<::flatbuffers::Offset<canopy::io::Tensor>>(*tensors) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto operators__ = operators ? _fbb.CreateVector<::flatbuffers::Offset<canopy::io::Operator>>(*operators) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return canopy::io::CreateSubGraph(
      _fbb,
      tensors__,
      inputs__,
      outputs__,
      operators__,
      name__);
}

struct Buffer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct BufferBuilder {
  typedef Buffer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Buffer::VT_DATA, data);
  }
  explicit BufferBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Buffer>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Buffer> CreateBuffer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  BufferBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Buffer> CreateBufferDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return canopy::io::CreateBuffer(
      _fbb,
      data__);
}

struct DAGs FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DAGsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBGRAPHS = 4,
    VT_BUFFERS = 6,
    VT_NAME = 8,
    VT_DESCRIPTION = 10
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<canopy::io::SubGraph>> *subgraphs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<canopy::io::SubGraph>> *>(VT_SUBGRAPHS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<canopy::io::Buffer>> *buffers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<canopy::io::Buffer>> *>(VT_BUFFERS);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SUBGRAPHS) &&
           verifier.VerifyVector(subgraphs()) &&
           verifier.VerifyVectorOfTables(subgraphs()) &&
           VerifyOffset(verifier, VT_BUFFERS) &&
           verifier.VerifyVector(buffers()) &&
           verifier.VerifyVectorOfTables(buffers()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           verifier.EndTable();
  }
};

struct DAGsBuilder {
  typedef DAGs Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_subgraphs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<canopy::io::SubGraph>>> subgraphs) {
    fbb_.AddOffset(DAGs::VT_SUBGRAPHS, subgraphs);
  }
  void add_buffers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<canopy::io::Buffer>>> buffers) {
    fbb_.AddOffset(DAGs::VT_BUFFERS, buffers);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(DAGs::VT_NAME, name);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(DAGs::VT_DESCRIPTION, description);
  }
  explicit DAGsBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DAGs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DAGs>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DAGs> CreateDAGs(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<canopy::io::SubGraph>>> subgraphs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<canopy::io::Buffer>>> buffers = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0) {
  DAGsBuilder builder_(_fbb);
  builder_.add_description(description);
  builder_.add_name(name);
  builder_.add_buffers(buffers);
  builder_.add_subgraphs(subgraphs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DAGs> CreateDAGsDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<canopy::io::SubGraph>> *subgraphs = nullptr,
    const std::vector<::flatbuffers::Offset<canopy::io::Buffer>> *buffers = nullptr,
    const char *name = nullptr,
    const char *description = nullptr) {
  auto subgraphs__ = subgraphs ? _fbb.CreateVector<::flatbuffers::Offset<canopy::io::SubGraph>>(*subgraphs) : 0;
  auto buffers__ = buffers ? _fbb.CreateVector<::flatbuffers::Offset<canopy::io::Buffer>>(*buffers) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  return canopy::io::CreateDAGs(
      _fbb,
      subgraphs__,
      buffers__,
      name__,
      description__);
}

inline bool VerifyOperatorArgs(::flatbuffers::Verifier &verifier, const void *obj, OperatorArgs type) {
  switch (type) {
    case OperatorArgs_NONE: {
      return true;
    }
    case OperatorArgs_KofNArgs: {
      auto ptr = reinterpret_cast<const canopy::io::KofNArgs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OperatorArgs_ReshapeArgs: {
      auto ptr = reinterpret_cast<const canopy::io::ReshapeArgs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OperatorArgs_MonteCarloExpectedValueOptions: {
      auto ptr = reinterpret_cast<const canopy::io::MonteCarloExpectedValueOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyOperatorArgsVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOperatorArgs(
        verifier,  values->Get(i), types->GetEnum<OperatorArgs>(i))) {
      return false;
    }
  }
  return true;
}

inline const canopy::io::DAGs *GetDAGs(const void *buf) {
  return ::flatbuffers::GetRoot<canopy::io::DAGs>(buf);
}

inline const canopy::io::DAGs *GetSizePrefixedDAGs(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<canopy::io::DAGs>(buf);
}

inline const char *DAGsIdentifier() {
  return "CPY1";
}

inline bool DAGsBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, DAGsIdentifier());
}

inline bool SizePrefixedDAGsBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, DAGsIdentifier(), true);
}

inline bool VerifyDAGsBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<canopy::io::DAGs>(DAGsIdentifier());
}

inline bool VerifySizePrefixedDAGsBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<canopy::io::DAGs>(DAGsIdentifier());
}

inline const char *DAGsExtension() {
  return "cnpy";
}

inline void FinishDAGsBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<canopy::io::DAGs> root) {
  fbb.Finish(root, DAGsIdentifier());
}

inline void FinishSizePrefixedDAGsBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<canopy::io::DAGs> root) {
  fbb.FinishSizePrefixed(root, DAGsIdentifier());
}

}  // namespace io
}  // namespace canopy

#endif  // FLATBUFFERS_GENERATED_SCHEMAV1_CANOPY_IO_H_
